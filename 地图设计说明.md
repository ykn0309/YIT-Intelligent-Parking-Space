10.30：
对于每个特定的停车场，分别设计一张停车场地图

地图的每个格子作为表中的一项属性

寻路算法需要传入这个地图的信息，然后传入车辆当前的坐标（如果后续扩展则需要额外输入车的型号之类的），算法输出一个由xy坐标组成的数组，存储了从输入坐标到最优车位之间的路径，交给前端进行显示。

map_a表格是一个示例，左上，右上，左下，右下分别为A,B,C,D区域，绿色是车位，边框是车位分界线，黄色小方块是出入口。

map_b表格是一个障碍更多的示例，模拟实际情况中可能出现的情形。黑色部分不可通行，所以路线的规划变得更复杂。

11.1补充：

为了简化，不对地图额外建表，将出入口信息存到ParkLocationEntity中，然后寻路算法传参作出以下改变：

PathFindingUtil成员变量是这些，无论是停车/开走都是这样，只不过调用的函数不同。
```java
public Coordinate destination; // 目的地坐标
public List<Coordinate> path; // 路径坐标列表
```
其中Coordinate是一个自定义了x,y坐标的类。目的地坐标为车位左上角/目的出口，用来修改ParkLocationEntity的某些属性，path用于返回给前端。第一代版本中path总是导到左上角。

PathFindingUtil函数有
```java
public void findInPath(int[][] map, int startX, int startY)
和
```
```java
public void findOutPath(int[][] map, int startX, int startY)
```
分别表示找进入的路和出来的路。传入当前的地图信息和起始位置，算法就会根据这些来算出终点并返回一个路径列表。

map数组的值规定如下：

最后1位：是否可以通行：1-是；0-否（永远不能跨车位通行）

倒数第2位：是否是车位：1-是；0-否

倒数第3位：是否车位被占用了：1-是；0-否（不是车位的永远是0）

倒数第4位：是否是车位的左上角，也就是ParkLocationEntity中存的位置：1-是；0-否

倒数第5位：是否是出口：1-是；0-否

倒数第6位：是否是入口：1-是；0-否

举例说明：一个出入口，可以通行，就是0x110001（49）；一个车位的右下角，没被占用就是0x000010（2），占用就是0x000110（6）；一块普通的畅通无阻的道路，就是0x000001（1）